<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>Products</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="/css/common.css">
    <link rel="stylesheet" type="text/css" href="/css/nav-sidebar.css">
    <link rel="stylesheet" type="text/css" href="/css/home-common.css">
    <link rel="stylesheet" type="text/css" href="/css/business.css">
    <meta name="_csrf" th:content="${_csrf.token}"/>
    <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
</head>
<body class="homepage-body">
<div class="top-bar">
    <h1 class="logo">
        <a href="/home" class="logo-link">
            <img src="/images/only-logo.png" alt="Inventorize Logo" class="logo-icon">
            <span class="logo-text">inventorize</span>
        </a>
    </h1>
    <div class="btn-group">
        <a th:href="@{/logout}" class="button">Logout</a>
    </div>
</div>
<div class="main-layout">
    <aside class="sidebar">
        <div class="sidebar-top">
            <div class="sidebar-user-info">
                <div class="sidebar-user-name" th:text="${user.firstName + ' ' + user.lastName}">John Doe</div>
                <div class="sidebar-user-role" th:text="${user.role.displayName}">Admin</div>
            </div>
            <div class="sidebar-section top-section">
                <a class="sidebar-btn rounded-btn home-btn" href="/home">Home</a>
            </div>
            <div class="sidebar-divider"></div>
            <div class="sidebar-section middle-section">
                <div class="sidebar-section-label">Business</div>
                <a class="sidebar-btn rounded-btn" th:href="@{'/businesses/' + ${business.id} + '/products'}">Products</a>
                <a class="sidebar-btn rounded-btn" th:href="@{'/businesses/' + ${business.id} + '/employees'}" sec:authorize="hasRole('ROLE_ADMIN') or hasRole('ROLE_MANAGER')">Employees</a>
            </div>
            <div class="sidebar-divider"></div>
            <div class="sidebar-section middle-section">
                <div class="sidebar-section-label">Profile settings</div>
                <a class="sidebar-btn rounded-btn" th:href="@{'/users/' + ${user.id} + '/profile'}">Edit Profile</a>
            </div>
        </div>
        <div class="sidebar-bottom">
            <div class="sidebar-divider"></div>
            <div class="sidebar-section bottom-section" sec:authorize="hasRole('ROLE_ADMIN')">
                <div class="sidebar-section-label">Admin</div>
                <a class="sidebar-btn rounded-btn" href="/businesses">Businesses</a>
                <a class="sidebar-btn rounded-btn" href="/users">Users</a>
            </div>
        </div>
    </aside>
    <main class="content-area">
        <div class="products-container">
            <div class="products-header">
                <div class="header-buttons">
                    <button type="button" class="add-btn" id="addBtn">Add</button>
                    <button type="button" class="cancel-add-btn" id="cancelAddBtn" style="display: none; background-color: #e53935; color: #ffffff; border: none;">Cancel</button>
                    <button type="button" class="edit-btn" id="editBtn">Edit</button>
                    <button type="button" class="delete-btn" id="deleteBtn">Delete</button>
                </div>
                <h2 class="products-title">Products</h2>
            </div>
            <div class="products-grid">
                <div class="grid-header">
                    <div class="grid-cell header-cell">#</div>
                    <div class="grid-cell header-cell">Name</div>
                    <div class="grid-cell header-cell">Brand</div>
                    <div class="grid-cell header-cell">Category</div>
                    <div class="grid-cell header-cell">Min Threshold</div>
                    <div class="grid-cell header-cell">Max Threshold</div>
                    <div class="grid-cell header-cell">Arrival Date</div>
                    <div class="grid-cell header-cell">Expiry Date</div>
                    <div class="grid-cell header-cell">Price</div>
                    <div class="grid-cell header-cell">Unit</div>
                    <div class="grid-cell header-cell">Quantity</div>
                </div>
                <label class="grid-row" th:each="product, iterStat : ${products}">
                    <input type="radio" name="selectedProduct" class="row-radio" th:value="${product.id}" th:checked="${selectedProductId != null and selectedProductId == product.id}">
                    <div class="grid-cell row-number"></div>
                    <div class="grid-cell">
                        <span class="cell-text" th:text="${product.name}">Product Name</span>
                        <input type="text" class="cell-input" th:value="${product.name}" style="display: none;">
                    </div>
                    <div class="grid-cell">
                        <span class="cell-text" th:text="${product.brand}">Brand</span>
                        <input type="text" class="cell-input" th:value="${product.brand}" style="display: none;">
                    </div>
                    <div class="grid-cell">
                        <span class="cell-text" th:text="${product.category != null ? T(bg.softuni.Inventorize.product.model.ProductCategory).valueOf(product.category.toString()).displayName : product.category}">Category</span>
                        <select class="category-select cell-input" style="display: none;" th:data-category="${product.category}">
                            <option value="">Select Category</option>
                            <option th:each="category : ${T(bg.softuni.Inventorize.product.model.ProductCategory).values()}"
                                    th:value="${category.name()}"
                                    th:text="${category.displayName}"
                                    th:selected="${product.category == category.name()}">
                            </option>
                        </select>
                    </div>
                    <div class="grid-cell">
                        <span class="cell-text" th:text="${product.minStockThreshold}">10</span>
                        <input type="number" class="cell-input" th:value="${product.minStockThreshold}" style="display: none;">
                    </div>
                    <div class="grid-cell">
                        <span class="cell-text" th:text="${product.maxStockThreshold}">100</span>
                        <input type="number" class="cell-input" th:value="${product.maxStockThreshold}" style="display: none;">
                    </div>
                    <div class="grid-cell">
                        <span class="cell-text" th:text="${product.arrivalDate}">2025-01-15</span>
                        <input type="date" class="cell-input" th:value="${product.arrivalDate}" style="display: none;">
                    </div>
                    <div class="grid-cell">
                        <span class="cell-text" th:text="${product.expiryDate}">2025-12-31</span>
                        <input type="date" class="cell-input" th:value="${product.expiryDate}" style="display: none;">
                    </div>
                    <div class="grid-cell">
                        <span class="cell-text" th:text="'$' + ${product.price}">$29.99</span>
                        <input type="text" class="cell-input" th:value="${product.price}" style="display: none;">
                    </div>
                    <div class="grid-cell">
                        <span class="cell-text" th:text="${product.unit != null ? T(bg.softuni.Inventorize.product.model.ProductUnit).valueOf(product.unit.toString()).displayName : product.unit}">Piece</span>
                        <select class="unit-select cell-input" style="display: none;">
                            <option value="">Select Unit</option>
                            <option th:each="unit : ${T(bg.softuni.Inventorize.product.model.ProductUnit).values()}"
                                    th:value="${unit.name()}"
                                    th:text="${unit.displayName}"
                                    th:selected="${product.unit == unit.name()}">
                            </option>
                        </select>
                    </div>
                    <div class="grid-cell quantity-cell">
                        <span class="cell-text" th:text="${product.quantity}">50</span>
                        <input type="number" class="cell-input" th:value="${product.quantity}" style="display: none;">
                    </div>
                </label>
            </div>
        </div>
    </main>
</div>
<!-- Hidden template for category options (generated from enum) -->
<select id="categoryOptionsTemplate" style="display: none;">
    <option value="">Select Category</option>
    <option th:each="category : ${T(bg.softuni.Inventorize.product.model.ProductCategory).values()}"
            th:value="${category.name()}"
            th:text="${category.displayName}">
    </option>
</select>
<script type="text/javascript" th:inline="javascript">
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Business.js loaded successfully');

        // Set row numbers correctly (only for existing product rows, not new rows)
        // Filter out the header row and new rows
        const productRows = Array.from(document.querySelectorAll('.grid-row:not(.new-row)'));
        productRows.forEach(function(row, index) {
            const rowNumberCell = row.querySelector('.row-number');
            if (rowNumberCell) {
                rowNumberCell.textContent = (index + 1).toString();
            }
        });

        // Get business ID from Thymeleaf
        const businessId = /*[[${business.id}]]*/ null;

        // Get CSRF token
        const csrfToken = document.querySelector('meta[name="_csrf"]').content;
        const csrfHeader = document.querySelector('meta[name="_csrf_header"]').content;

        const editBtn = document.getElementById('editBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const addBtn = document.getElementById('addBtn');
        const cancelAddBtn = document.getElementById('cancelAddBtn');

        console.log('Buttons found:', { editBtn: !!editBtn, deleteBtn: !!deleteBtn, addBtn: !!addBtn });

        if (!editBtn || !deleteBtn || !addBtn || !cancelAddBtn) {
            console.error('One or more buttons not found:', { editBtn, deleteBtn, addBtn, cancelAddBtn });
            return;
        }

        let editMode = false;

        editBtn.addEventListener('click', function() {
            const selectedRow = document.querySelector('.row-radio:checked');
            if (!selectedRow) {
                alert('Please select a row to edit');
                return;
            }

            const row = selectedRow.closest('.grid-row');
            const isNewRow = row.classList.contains('new-row');

            // Don't allow editing new rows - they should be saved via Add button
            if (isNewRow) {
                alert('Please save the new product first using the Save button');
                return;
            }

            editMode = !editMode;

            if (editMode) {
                editBtn.textContent = 'Save';
                editBtn.classList.add('save-btn');
                // Initialize unit dropdown value
                const unitSelect = row.querySelector('.unit-select');
                if (unitSelect) {
                    const unitText = unitSelect.previousElementSibling;
                    if (unitText && unitText.classList.contains('cell-text')) {
                        const unitValue = unitText.textContent.trim();
                        // Try to find matching option
                        for (let i = 0; i < unitSelect.options.length; i++) {
                            if (unitSelect.options[i].text.trim() === unitValue ||
                                unitSelect.options[i].value === unitValue.toUpperCase().replace(' ', '_')) {
                                unitSelect.selectedIndex = i;
                                break;
                            }
                        }
                    }
                    unitSelect.style.display = 'block';
                }
                // Initialize category dropdown value
                const categorySelect = row.querySelector('.category-select');
                if (categorySelect) {
                    const categoryText = categorySelect.previousElementSibling;
                    if (categoryText && categoryText.classList.contains('cell-text')) {
                        const categoryValue = categoryText.textContent.trim();
                        // Try to find matching option
                        for (let i = 0; i < categorySelect.options.length; i++) {
                            if (categorySelect.options[i].text.trim() === categoryValue ||
                                categorySelect.options[i].value === categoryValue) {
                                categorySelect.selectedIndex = i;
                                break;
                            }
                        }
                    }
                    categorySelect.style.display = 'block';
                }
                // Show inputs and dropdowns, hide text
                row.querySelectorAll('.cell-text').forEach(function(text) {
                    text.style.display = 'none';
                });
                row.querySelectorAll('.cell-input').forEach(function(input) {
                    input.style.display = 'block';
                });
            } else {
                // Save mode - collect data and send to server
                const productId = selectedRow.value;

                // Collect all field values
                const cells = row.querySelectorAll('.grid-cell');

                const nameInput = cells[1] ? cells[1].querySelector('.cell-input[type="text"]') : null;
                const name = nameInput ? nameInput.value.trim() : '';

                const brandInput = cells[2] ? cells[2].querySelector('.cell-input[type="text"]') : null;
                const brand = brandInput ? brandInput.value.trim() : '';

                const categorySelect = cells[3] ? cells[3].querySelector('.category-select') : null;
                const category = categorySelect ? categorySelect.value : '';

                const minThresholdInput = cells[4] ? cells[4].querySelector('.cell-input[type="number"]') : null;
                const minThreshold = minThresholdInput ? minThresholdInput.value.trim() : '0';

                const maxThresholdInput = cells[5] ? cells[5].querySelector('.cell-input[type="number"]') : null;
                const maxThreshold = maxThresholdInput ? maxThresholdInput.value.trim() : '0';

                const arrivalDateInput = cells[6] ? cells[6].querySelector('.cell-input[type="date"]') : null;
                const arrivalDate = arrivalDateInput ? arrivalDateInput.value : '';

                const expiryDateInput = cells[7] ? cells[7].querySelector('.cell-input[type="date"]') : null;
                const expiryDate = expiryDateInput ? expiryDateInput.value : '';

                const priceInput = cells[8] ? cells[8].querySelector('.cell-input[type="text"]') : null;
                const price = priceInput ? priceInput.value.trim() : '';

                const unitSelect = cells[9] ? cells[9].querySelector('.unit-select') : null;
                const unit = unitSelect ? unitSelect.value : '';

                const quantityInput = cells[10] ? cells[10].querySelector('.cell-input[type="number"]') : null;
                const quantity = quantityInput ? quantityInput.value.trim() : '0';

                // Validate required fields
                if (!name || !brand || !category || !price || !unit) {
                    alert('Please fill in all required fields (Name, Brand, Category, Price, Unit)');
                    editMode = true; // Keep in edit mode
                    return;
                }

                // Send update to server
                const formData = new FormData();
                formData.append('name', name);
                formData.append('brand', brand);
                formData.append('category', category);
                formData.append('minThreshold', minThreshold);
                formData.append('maxThreshold', maxThreshold);
                formData.append('arrivalDate', arrivalDate);
                formData.append('expiryDate', expiryDate);
                formData.append('price', price);
                formData.append('unit', unit);
                formData.append('quantity', quantity);
                formData.append('_csrf', csrfToken);

                fetch('/businesses/' + businessId + '/products/' + productId + '/edit', {
                    method: 'PUT',
                    headers: {
                        [csrfHeader]: csrfToken
                    },
                    body: formData,
                    redirect: 'manual'
                })
                    .then(response => {
                        // Spring returns redirect (302) on success
                        // With redirect: 'manual', we get the redirect response
                        // Check if it's a redirect (status 0 or 302) or success (2xx)
                        const status = response.status;
                        const isRedirect = status === 0 || status === 302 || response.type === 'opaqueredirect';
                        const isSuccess = status >= 200 && status < 300;

                        if (isRedirect || isSuccess || response.redirected) {
                            // Success - reload page to get updated data
                            window.location.reload();
                        } else if (status >= 400) {
                            // Error - show message
                            response.text().then(text => {
                                console.error('Update failed:', status, text);
                                alert('Failed to update product. Please try again.');
                                editMode = true; // Keep in edit mode on error
                            }).catch(() => {
                                alert('Failed to update product. Please try again.');
                                editMode = true;
                            });
                        } else {
                            // Unknown status - assume success (might be redirect)
                            window.location.reload();
                        }
                    })
                    .catch(error => {
                        console.error('Error updating product:', error);
                        alert('An error occurred while updating the product.');
                        editMode = true; // Keep in edit mode on error
                    });

                // Update UI immediately (will be refreshed from server)
                editBtn.textContent = 'Edit';
                editBtn.classList.remove('save-btn');
                // Update unit dropdown text value first (reuse unitSelect from above)
                if (unitSelect) {
                    const unitText = unitSelect.previousElementSibling;
                    if (unitText && unitText.classList.contains('cell-text')) {
                        const selectedOption = unitSelect.options[unitSelect.selectedIndex];
                        unitText.textContent = selectedOption ? selectedOption.text : unitSelect.value;
                    }
                    unitSelect.style.display = 'none';
                }
                // Update category dropdown text value (reuse categorySelect from above)
                if (categorySelect) {
                    const categoryText = categorySelect.previousElementSibling;
                    if (categoryText && categoryText.classList.contains('cell-text')) {
                        const selectedOption = categorySelect.options[categorySelect.selectedIndex];
                        categoryText.textContent = selectedOption ? selectedOption.text : categorySelect.value;
                    }
                    categorySelect.style.display = 'none';
                }
                // Hide inputs and dropdowns, show text
                row.querySelectorAll('.cell-input').forEach(function(input) {
                    input.style.display = 'none';
                    // Update text value
                    if (input.type !== 'date' && input.tagName !== 'SELECT') {
                        const text = input.previousElementSibling;
                        if (text && text.classList.contains('cell-text')) {
                            text.textContent = input.value;
                        }
                    } else if (input.type === 'date') {
                        const text = input.previousElementSibling;
                        if (text && text.classList.contains('cell-text')) {
                            text.textContent = input.value || '-';
                        }
                    }
                });
                row.querySelectorAll('.cell-text').forEach(function(text) {
                    text.style.display = 'inline';
                });
            }
        });

        // Exit edit mode when another row is selected
        document.querySelectorAll('.row-radio').forEach(function(radio) {
            radio.addEventListener('change', function() {
                if (editMode) {
                    editMode = false;
                    editBtn.textContent = 'Edit';
                    editBtn.classList.remove('save-btn');

                    // Reset all rows
                    document.querySelectorAll('.grid-row').forEach(function(row) {
                        row.querySelectorAll('.cell-input').forEach(function(input) {
                            input.style.display = 'none';
                        });
                        row.querySelectorAll('.cell-text').forEach(function(text) {
                            text.style.display = 'inline';
                        });
                        const unitSelect = row.querySelector('.unit-select');
                        if (unitSelect) {
                            unitSelect.style.display = 'none';
                        }
                        const categorySelect = row.querySelector('.category-select');
                        if (categorySelect) {
                            categorySelect.style.display = 'none';
                        }
                    });
                }
            });
        });

        // Delete button functionality
        if (deleteBtn) {
            deleteBtn.addEventListener('click', function() {
                const selectedRow = document.querySelector('.row-radio:checked');
                if (!selectedRow) {
                    alert('Please select a row to delete');
                    return;
                }

                const productId = selectedRow.value;
                const row = selectedRow.closest('.grid-row');
                const isNewRow = row.classList.contains('new-row');

                // Don't allow deleting new rows that haven't been saved
                if (isNewRow) {
                    alert('Cannot delete a product that has not been saved yet');
                    return;
                }

                if (confirm('Are you sure you want to delete this product?')) {
                    // Store reference to the row for removal
                    const rowToDelete = selectedRow.closest('.grid-row');

                    // Use POST with _method=DELETE for Spring's HiddenHttpMethodFilter
                    const deleteFormData = new FormData();
                    deleteFormData.append('_method', 'DELETE');
                    deleteFormData.append('_csrf', csrfToken);

                    fetch('/businesses/' + businessId + '/products/' + productId + '/delete', {
                        method: 'POST',
                        headers: {
                            [csrfHeader]: csrfToken
                        },
                        body: deleteFormData,
                        redirect: 'manual'
                    })
                        .then(response => {
                            // Spring returns redirect (302) on success
                            // With redirect: 'manual', we get the redirect response
                            // Check if it's a redirect (status 0 or 302) or success (2xx)
                            const status = response.status;
                            const isRedirect = status === 0 || status === 302 || response.type === 'opaqueredirect';
                            const isSuccess = status >= 200 && status < 300;

                            if (isRedirect || isSuccess || response.redirected) {
                                // Success - remove row from DOM dynamically
                                if (rowToDelete) {
                                    rowToDelete.remove();
                                }

                                // Update row numbers after deletion
                                const productRowsAfterDelete = Array.from(document.querySelectorAll('.grid-row:not(.new-row)'));
                                productRowsAfterDelete.forEach(function(row, index) {
                                    const rowNumberCell = row.querySelector('.row-number');
                                    if (rowNumberCell) {
                                        rowNumberCell.textContent = (index + 1).toString();
                                    }
                                });

                                // Unselect any selected radio button
                                const remainingSelected = document.querySelector('.row-radio:checked');
                                if (remainingSelected) {
                                    remainingSelected.checked = false;
                                }
                            } else if (status >= 400) {
                                // Error - show message
                                response.text().then(text => {
                                    console.error('Delete failed:', status, text);
                                    alert('Failed to delete product. Please try again.');
                                }).catch(() => {
                                    alert('Failed to delete product. Please try again.');
                                });
                            } else {
                                // Unknown status - assume success (might be redirect)
                                if (rowToDelete) {
                                    rowToDelete.remove();
                                }
                                const productRowsAfterDelete = Array.from(document.querySelectorAll('.grid-row:not(.new-row)'));
                                productRowsAfterDelete.forEach(function(row, index) {
                                    const rowNumberCell = row.querySelector('.row-number');
                                    if (rowNumberCell) {
                                        rowNumberCell.textContent = (index + 1).toString();
                                    }
                                });
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting product:', error);
                            alert('An error occurred while deleting the product.');
                        });
                }
            });
        }

        // Add button functionality - create new row
        const productsGrid = document.querySelector('.products-grid');
        if (!productsGrid) {
            console.error('Products grid not found');
            return;
        }

        let newRowCounter = 1000; // Start with high number to avoid conflicts
        let currentNewRow = null; // Track the current new row being added

        if (addBtn) {
            addBtn.addEventListener('click', function() {
                // If button says "Save", save the current new row
                if (addBtn.textContent === 'Save' && currentNewRow) {
                    const selectedRadio = currentNewRow.querySelector('.row-radio');
                    if (selectedRadio) {
                        saveNewRow(currentNewRow, selectedRadio);
                    }
                    return;
                }

                // Otherwise, create a new row (button says "Add")
                // Reset any previous new row state
                if (currentNewRow) {
                    currentNewRow.remove();
                }

                // Create new row
                const newRow = document.createElement('label');
                newRow.className = 'grid-row new-row';
                currentNewRow = newRow; // Store reference to current new row

                const rowId = 'new-row-' + (newRowCounter++);
                const radioValue = 'new-' + newRowCounter;

                newRow.innerHTML = `
                        <input type="radio" name="selectedProduct" class="row-radio" value="${radioValue}" id="${rowId}">
                        <div class="grid-cell row-number"></div>
                        <div class="grid-cell">
                            <span class="cell-text" style="display: none;"></span>
                            <input type="text" class="cell-input" placeholder="Enter product name" value="" style="display: block;">
                        </div>
                        <div class="grid-cell">
                            <span class="cell-text" style="display: none;"></span>
                            <input type="text" class="cell-input" placeholder="Enter brand" value="" style="display: block;">
                        </div>
                        <div class="grid-cell">
                            <span class="cell-text" style="display: none;"></span>
                            <select class="category-select cell-input" style="display: block;">
                                <!-- Options will be populated from template -->
                            </select>
                        </div>
                        <div class="grid-cell">
                            <span class="cell-text" style="display: none;"></span>
                            <input type="number" class="cell-input" placeholder="Min" value="" style="display: block;">
                        </div>
                        <div class="grid-cell">
                            <span class="cell-text" style="display: none;"></span>
                            <input type="number" class="cell-input" placeholder="Max" value="" style="display: block;">
                        </div>
                        <div class="grid-cell">
                            <span class="cell-text" style="display: none;"></span>
                            <input type="date" class="cell-input" placeholder="Arrival Date" value="" style="display: block;">
                        </div>
                        <div class="grid-cell">
                            <span class="cell-text" style="display: none;"></span>
                            <input type="date" class="cell-input" placeholder="Expiry Date" value="" style="display: block;">
                        </div>
                        <div class="grid-cell">
                            <span class="cell-text" style="display: none;"></span>
                            <input type="text" class="cell-input" placeholder="Enter price" value="" style="display: block;">
                        </div>
                        <div class="grid-cell">
                            <span class="cell-text" style="display: none;"></span>
                            <select class="unit-select cell-input" style="display: block;">
                                <option value="">Select Unit</option>
                                <option value="PIECE">Piece</option>
                                <option value="KG">Kilogram</option>
                                <option value="L">Liter</option>
                                <option value="BOX">Box</option>
                                <option value="CASE">Case</option>
                                <option value="PACK">Pack</option>
                                <option value="BOTTLE">Bottle</option>
                                <option value="CARTON">Carton</option>
                            </select>
                        </div>
                        <div class="grid-cell quantity-cell">
                            <span class="cell-text" style="display: none;">0</span>
                            <input type="number" class="cell-input" placeholder="Quantity" value="0" style="display: block;">
                        </div>
                    `;

                // Insert before the last row (or at the end if no rows exist)
                const existingRows = productsGrid.querySelectorAll('.grid-row');
                if (existingRows.length > 0) {
                    productsGrid.insertBefore(newRow, existingRows[existingRows.length - 1].nextSibling);
                } else {
                    productsGrid.appendChild(newRow);
                }

                // Populate category select from template (enum values)
                const categorySelect = newRow.querySelector('.category-select');
                const categoryTemplate = document.getElementById('categoryOptionsTemplate');
                if (categorySelect && categoryTemplate) {
                    // Clone all options from template
                    Array.from(categoryTemplate.options).forEach(function(option) {
                        const newOption = option.cloneNode(true);
                        categorySelect.appendChild(newOption);
                    });
                }

                // Auto-select the new row
                document.getElementById(rowId).checked = true;

                // Update row numbers after adding new row (exclude new row from count)
                const productRowsAfterAdd = Array.from(document.querySelectorAll('.grid-row:not(.new-row)'));
                productRowsAfterAdd.forEach(function(row, index) {
                    const rowNumberCell = row.querySelector('.row-number');
                    if (rowNumberCell) {
                        rowNumberCell.textContent = (index + 1).toString();
                    }
                });

                // Change Add button to Save
                addBtn.textContent = 'Save';
                addBtn.classList.add('save-btn');

                // Show Cancel button and hide Edit and Delete buttons when adding a new product
                cancelAddBtn.style.display = 'inline-block';
                if (editBtn) {
                    editBtn.style.display = 'none';
                }
                if (deleteBtn) {
                    deleteBtn.style.display = 'none';
                }

                // Reset edit mode if active
                if (editMode) {
                    editMode = false;
                    editBtn.textContent = 'Edit';
                    editBtn.classList.remove('save-btn');
                }
            });
        }

        // Cancel button functionality - cancel adding new product
        if (cancelAddBtn) {
            cancelAddBtn.addEventListener('click', function() {
                // If there is a new row being edited, remove it
                if (currentNewRow) {
                    currentNewRow.remove();
                    currentNewRow = null;
                }

                // Reset Add button back to "Add"
                addBtn.textContent = 'Add';
                addBtn.classList.remove('save-btn');

                // Hide Cancel button and show Edit and Delete buttons again
                cancelAddBtn.style.display = 'none';
                if (editBtn) {
                    editBtn.style.display = '';
                }
                if (deleteBtn) {
                    deleteBtn.style.display = '';
                }

                // Recalculate row numbers for existing rows
                const productRowsAfterCancel = Array.from(document.querySelectorAll('.grid-row:not(.new-row)'));
                productRowsAfterCancel.forEach(function(row, index) {
                    const rowNumberCell = row.querySelector('.row-number');
                    if (rowNumberCell) {
                        rowNumberCell.textContent = (index + 1).toString();
                    }
                });
            });
        }

        // Function to save a new row
        function saveNewRow(row, radio) {
            // Get all cells (skip row-number which is at index 0)
            const cells = row.querySelectorAll('.grid-cell');

            // Collect all field values by accessing each cell
            const nameInput = cells[1] ? cells[1].querySelector('.cell-input[type="text"]') : null;
            const name = nameInput ? nameInput.value.trim() : '';

            const brandInput = cells[2] ? cells[2].querySelector('.cell-input[type="text"]') : null;
            const brand = brandInput ? brandInput.value.trim() : '';

            const categorySelect = cells[3] ? cells[3].querySelector('.category-select') : null;
            const category = categorySelect ? categorySelect.value : '';

            const minThresholdInput = cells[4] ? cells[4].querySelector('.cell-input[type="number"]') : null;
            const minThreshold = minThresholdInput ? minThresholdInput.value.trim() : '';

            const maxThresholdInput = cells[5] ? cells[5].querySelector('.cell-input[type="number"]') : null;
            const maxThreshold = maxThresholdInput ? maxThresholdInput.value.trim() : '';

            const arrivalDateInput = cells[6] ? cells[6].querySelector('.cell-input[type="date"]') : null;
            const arrivalDate = arrivalDateInput ? arrivalDateInput.value : '';

            const expiryDateInput = cells[7] ? cells[7].querySelector('.cell-input[type="date"]') : null;
            const expiryDate = expiryDateInput ? expiryDateInput.value : '';

            const priceInput = cells[8] ? cells[8].querySelector('.cell-input[type="text"]') : null;
            const price = priceInput ? priceInput.value.trim() : '';

            const unitSelect = cells[9] ? cells[9].querySelector('.unit-select') : null;
            const unit = unitSelect ? unitSelect.value : '';

            const quantityInput = cells[10] ? cells[10].querySelector('.cell-input[type="number"]') : null;
            const quantity = quantityInput ? quantityInput.value.trim() : '0';

            // Validate required fields
            if (!name || !brand || !category || !price || !unit) {
                alert('Please fill in all required fields (Name, Brand, Category, Price, Unit)');
                return;
            }

            // Send data to server
            const formData = new FormData();
            formData.append('name', name);
            formData.append('brand', brand);
            formData.append('category', category);
            formData.append('minThreshold', minThreshold);
            formData.append('maxThreshold', maxThreshold);
            formData.append('arrivalDate', arrivalDate);
            formData.append('expiryDate', expiryDate);
            formData.append('price', price);
            formData.append('unit', unit);
            formData.append('quantity', quantity);
            formData.append('_csrf', csrfToken);

            fetch('/businesses/' + businessId + '/products/new', {
                method: 'POST',
                headers: {
                    [csrfHeader]: csrfToken
                },
                body: formData,
                redirect: 'manual'
            })
                .then(response => {
                    // Spring returns redirect (302) on success
                    // With redirect: 'manual', we get the redirect response
                    // Check if it's a redirect (status 0 or 302) or success (2xx)
                    const status = response.status;
                    const isRedirect = status === 0 || status === 302 || response.type === 'opaqueredirect';
                    const isSuccess = status >= 200 && status < 300;

                    if (isRedirect || isSuccess || response.redirected) {
                        // Success - reload page to get updated data
                        window.location.reload();
                    } else if (status >= 400) {
                        // Error - show message
                        response.text().then(text => {
                            console.error('Save failed:', status, text);
                            alert('Failed to save product. Please try again.');
                        }).catch(() => {
                            alert('Failed to save product. Please try again.');
                        });
                    } else {
                        // Unknown status - assume success (might be redirect)
                        window.location.reload();
                    }
                })
                .catch(error => {
                    console.error('Error saving product:', error);
                    alert('An error occurred while saving the product.');
                });

            // Note: UI updates below will be overridden by page reload on success
            // But we keep them for immediate feedback in case of error

            // Reset Add button back to "Add"
            if (addBtn) {
                addBtn.textContent = 'Add';
                addBtn.classList.remove('save-btn');
            }

            // Show Edit and Delete buttons again after saving
            if (editBtn) {
                editBtn.style.display = '';
            }
            if (deleteBtn) {
                deleteBtn.style.display = '';
            }

            // Reset edit button if needed
            editBtn.textContent = 'Edit';
            editBtn.classList.remove('save-btn');
            editMode = false;
            currentNewRow = null; // Clear the current new row reference

            // Update name
            if (cells[1]) {
                const textSpan = cells[1].querySelector('.cell-text');
                if (textSpan) {
                    textSpan.textContent = name;
                    textSpan.style.display = 'inline';
                }
                if (nameInput) nameInput.style.display = 'none';
            }

            // Update brand
            if (cells[2]) {
                const textSpan = cells[2].querySelector('.cell-text');
                if (textSpan) {
                    textSpan.textContent = brand;
                    textSpan.style.display = 'inline';
                }
                if (brandInput) brandInput.style.display = 'none';
            }

            // Update category
            if (cells[3] && categorySelect) {
                const textSpan = cells[3].querySelector('.cell-text');
                if (textSpan) {
                    const selectedOption = categorySelect.options[categorySelect.selectedIndex];
                    textSpan.textContent = selectedOption ? selectedOption.text : category;
                    textSpan.style.display = 'inline';
                }
                categorySelect.style.display = 'none';
            }

            // Update min threshold
            if (cells[4] && minThresholdInput) {
                const textSpan = cells[4].querySelector('.cell-text');
                if (textSpan) {
                    textSpan.textContent = minThreshold || '0';
                    textSpan.style.display = 'inline';
                }
                minThresholdInput.style.display = 'none';
            }

            // Update max threshold
            if (cells[5] && maxThresholdInput) {
                const textSpan = cells[5].querySelector('.cell-text');
                if (textSpan) {
                    textSpan.textContent = maxThreshold || '0';
                    textSpan.style.display = 'inline';
                }
                maxThresholdInput.style.display = 'none';
            }

            // Update arrival date
            if (cells[6] && arrivalDateInput) {
                const textSpan = cells[6].querySelector('.cell-text');
                if (textSpan) {
                    textSpan.textContent = arrivalDate || '-';
                    textSpan.style.display = 'inline';
                }
                arrivalDateInput.style.display = 'none';
            }

            // Update expiry date
            if (cells[7] && expiryDateInput) {
                const textSpan = cells[7].querySelector('.cell-text');
                if (textSpan) {
                    textSpan.textContent = expiryDate || '-';
                    textSpan.style.display = 'inline';
                }
                expiryDateInput.style.display = 'none';
            }

            // Update price
            if (cells[8] && priceInput) {
                const textSpan = cells[8].querySelector('.cell-text');
                if (textSpan) {
                    textSpan.textContent = price;
                    textSpan.style.display = 'inline';
                }
                priceInput.style.display = 'none';
            }

            // Update unit
            if (cells[9] && unitSelect) {
                const textSpan = cells[9].querySelector('.cell-text');
                if (textSpan) {
                    const selectedOption = unitSelect.options[unitSelect.selectedIndex];
                    textSpan.textContent = selectedOption ? selectedOption.text : unit;
                    textSpan.style.display = 'inline';
                }
                unitSelect.style.display = 'none';
            }

            // Update quantity
            if (cells[10] && quantityInput) {
                const textSpan = cells[10].querySelector('.cell-text');
                if (textSpan) {
                    textSpan.textContent = quantity || '0';
                    textSpan.style.display = 'inline';
                }
                quantityInput.style.display = 'none';
            }

        }
    });
</script>
<footer class="copyright">
    <p>Â© 2025 inventorize. All rights reserved.</p>
</footer>
</body>
</html>
